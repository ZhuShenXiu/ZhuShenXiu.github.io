{"meta":{"title":"神秀!","subtitle":"知识分享!","description":"一个非常棒的知识分享博客哦!","author":"ZhuLiang","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-11-14T12:31:31.000Z","updated":"2021-11-14T12:32:03.467Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-14T12:32:12.000Z","updated":"2021-11-14T12:32:44.226Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-14T12:30:28.000Z","updated":"2021-11-14T12:39:32.110Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"page","slug":"page","date":"2021-11-17T11:07:48.000Z","updated":"2021-11-17T11:07:48.521Z","comments":true,"path":"2021/11/17/page/","link":"","permalink":"http://example.com/2021/11/17/page/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Processing","slug":"PROCESSING/index","date":"2021-11-14T13:51:45.000Z","updated":"2021-11-17T11:13:48.674Z","comments":true,"path":"2021/11/14/PROCESSING/index/","link":"","permalink":"http://example.com/2021/11/14/PROCESSING/index/","excerpt":"","text":"processing太空漫游代码及原理 一、首先创建星星类 1234567891011121314151617class Star&#123; int _color[] = &#123;255,255,255&#125;; //星星的颜色 float x; //x坐标 float y; //y坐标 float z; //控制星星向四周移动的值 //初始化 Star()&#123; //在屏幕随机生成 x = random(-width/2,width/2); y = random(-height/2,height/2); z = random(0,width); for(int i = 0; i &lt; _color.length; i++)&#123; _color[i] = (int)random(10,255); //给每个星星初始化不同颜色 &#125; &#125;&#125; 二、 用star数组统一管理，循环初始化 1234Star[] stars = new Star[350]; for(int i = 0; i &lt; stars.length; i++)&#123; //init stars[i] = new Star(); &#125; 三、让星星不断向四周移动，就有了模拟前进的效果 1234567891011121314151617181920212223//通过update改变z的值，让每一个星星向四周移动//z == 0 时，其对象代表的星星坐标已经移动出屏幕外，让其重新随机在屏幕内生成。z同时恢复初值void update()&#123; //设置初始速度，后续可以通过点击鼠标改变速度 z = z - speed; if(z &lt; 1)&#123; z = width; x = random(-width/2,width/2); y = random(-height/2,height/2); &#125; &#125; //绘制星星方法 void show()&#123; fill(_color[0],_color[1],_color[2]); //随着z的减小，sx,sy 是不断增大的，所以每次绘制就逐渐远离屏幕中心 float sx = map(x / z, 0, 1, 0, width); float sy = map(y / z, 0, 1, 0, height); //星星越近，半径越大 float r = map(z,0,width, 20, 2); ellipse(sx,sy,r,r); &#125; 四、通过移动鼠标位置改变坐标系中心轴的位置来改变方向 1234mx = map(mouseX,0,width,-500,500);my = map(mouseY,0,height,-500,500);//调整坐标中心点位置translate(width/2 + mx,height/2 + my); 五、通过判断鼠标是否点击加速或减速，设置速度的最高阈值和最低阈值 123456789101112float speed = 15;void speedup()&#123; if (mousePressed == true)&#123; if(speed &lt;= 75)&#123; speed += 1; &#125; &#125;else&#123; if(speed &gt;= 15)&#123; speed -= 1; &#125; &#125;&#125; 完整演示代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Star[] stars = new Star[350];float speed = 15, mx, my;void setup()&#123; size(1800,1300,P2D); for(int i = 0; i &lt; stars.length; i++)&#123; stars[i] = new Star(); &#125;&#125;void draw()&#123; background(0); speedup(); mx = map(mouseX,0,width,-500,500); my = map(mouseY,0,height,-500,500); //调整坐标中心点位置 translate(width/2 + mx,height/2 + my); for(int i = 0; i &lt; stars.length; i++)&#123; stars[i].update(); stars[i].show(); &#125;&#125;class Star&#123; int _color[] = &#123;255,255,255&#125;; float x; float y; float z; Star()&#123; x = random(-width/2,width/2); y = random(-height/2,height/2); z = random(0,width); for(int i = 0; i &lt; _color.length; i++)&#123; _color[i] = (int)random(10,255); &#125; &#125; void update()&#123; z = z - speed; if(z &lt; 1)&#123; z = width; x = random(-width/2,width/2); y = random(-height/2,height/2); &#125; &#125; void show()&#123; fill(_color[0],_color[1],_color[2]); //随着z的减小，sx,sy 是不断增大的，所以每次绘制就逐渐远离屏幕中心 float sx = map(x / z, 0, 1, 0, width); float sy = map(y / z, 0, 1, 0, height); //星星越近，半径越大 float r = map(z,0,width, 20, 2); ellipse(sx,sy,r,r); &#125;&#125;void speedup()&#123; if (mousePressed == true)&#123; if(speed &lt;= 75)&#123; speed += 1; &#125; &#125;else&#123; if(speed &gt;= 15)&#123; speed -= 1; &#125; &#125;&#125; 祝大家学习愉快！","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构/index","date":"2021-11-14T12:36:45.000Z","updated":"2021-11-17T11:00:05.881Z","comments":true,"path":"2021/11/14/数据结构/index/","link":"","permalink":"http://example.com/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index/","excerpt":"","text":"n− 皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数 n，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数 n。 输出格式 每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。 其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。 每个方案输出完成后，输出一个空行。 注意：行末不能有多余空格。 输出方案的顺序任意，只要不重复且没有遗漏即可。 数据范围 1≤n≤9 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int N = 20;char g[N][N];bool row[N], col[N], dg[N], udg[N]; //行 列 对角线 反对角线int n;void dfs(int x, int y, int s)&#123; if(y == n)&#123; y = 0; x++; &#125; if(x == n)&#123; if(s == n)&#123; for(int i = 0; i &lt; n; i++) puts(g[i]); puts(&quot;&quot;); &#125; return; &#125; //不放皇后 dfs(x, y + 1, s); //放皇后 if(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])&#123; g[x][y] = &#x27;Q&#x27;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; //true表示放置过 dfs(x, y + 1, s + 1); row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = &#x27;.&#x27;; &#125; &#125;int main()&#123; cin &gt;&gt; n; //初始化 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; g[i][j] = &#x27;.&#x27;; &#125; &#125; dfs(0, 0, 0); return 0;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}