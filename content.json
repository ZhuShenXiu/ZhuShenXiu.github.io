{"meta":{"title":"神秀!","subtitle":"知识分享!","description":"一个非常棒的知识分享博客哦!","author":"ZhuLiang","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-11-14T12:31:31.000Z","updated":"2021-11-14T12:32:03.467Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-14T12:32:12.000Z","updated":"2021-11-14T12:32:44.226Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-14T12:30:28.000Z","updated":"2021-11-14T12:39:32.110Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Processing","slug":"PROCESSING/index","date":"2021-11-14T13:51:45.000Z","updated":"2021-11-14T13:53:58.487Z","comments":true,"path":"2021/11/14/PROCESSING/index/","link":"","permalink":"http://example.com/2021/11/14/PROCESSING/index/","excerpt":"","text":"等待更新 QAQ","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构/index","date":"2021-11-14T12:36:45.000Z","updated":"2021-11-15T07:18:14.078Z","comments":true,"path":"2021/11/14/数据结构/index/","link":"","permalink":"http://example.com/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index/","excerpt":"","text":"n− 皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数 n，请你输出所有的满足条件的棋子摆法。 输入格式共一行，包含整数 n。 输出格式每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。 其中 . 表示某一个位置的方格状态为空，Q 表示某一个位置的方格上摆着皇后。 每个方案输出完成后，输出一个空行。 注意：行末不能有多余空格。 输出方案的顺序任意，只要不重复且没有遗漏即可。 数据范围1≤n≤9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int N = 20;char g[N][N];bool row[N], col[N], dg[N], udg[N]; //行 列 对角线 反对角线int n;void dfs(int x, int y, int s)&#123; if(y == n)&#123; y = 0; x++; &#125; if(x == n)&#123; if(s == n)&#123; for(int i = 0; i &lt; n; i++) puts(g[i]); puts(&quot;&quot;); &#125; return; &#125; //不放皇后 dfs(x, y + 1, s); //放皇后 if(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])&#123; g[x][y] = &#x27;Q&#x27;; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; //true表示放置过 dfs(x, y + 1, s + 1); row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = &#x27;.&#x27;; &#125; &#125;int main()&#123; cin &gt;&gt; n; //初始化 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; g[i][j] = &#x27;.&#x27;; &#125; &#125; dfs(0, 0, 0); return 0;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}